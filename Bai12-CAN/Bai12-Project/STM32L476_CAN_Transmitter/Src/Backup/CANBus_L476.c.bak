#include "stm32l476xx.h"
#include "CANBus_L476.h"

void CANBus_L476_Pins_Init(void)
{
	/*Enable clock access to GPIOB*/
	RCC->AHB2ENR |= RCC_AHB2ENR_GPIOBEN;
	
	GPIOB->MODER |=   GPIO_MODER_MODE8_1|GPIO_MODER_MODE9_1;
	GPIOB->MODER &=~ (GPIO_MODER_MODE8_0|GPIO_MODER_MODE9_0);
	
	/*Configure PB8 and PB9 to use CAN Bus AF*/
	GPIOB->AFR[1] |= (CAN_AF<<GPIO_AFRH_AFSEL8_Pos)|(CAN_AF<<GPIO_AFRH_AFSEL9_Pos);
}

void CANBus_L476_Init(void)
{
	/*Enable Clock access to CAN1*/
	RCC->APB1ENR1 |= RCC_APB1ENR1_CAN1EN;
	
	/* Enter Initialization mode*/
  CAN1->MCR |= CAN_MCR_INRQ;
  /*Wait until CANBus peripheral is in initialization mode*/
  while (!(CAN1->MSR & CAN_MSR_INAK)){}
	
	// Enable CAN1 peripheral
  CAN1->MCR &= ~CAN_MCR_SLEEP;
  while ((CAN1->MSR & CAN_MSR_SLAK)!=0U){}
		
	/*Configure the timing with the following parameters
	 * Normal mode.
	 * Loop back mode is disabled.
	 * Resynchronization jump width to 1 (value - 1).
	 * Prescale of 10. (value - 1)
	 * Time quanta segment 1 is 2 (value - 1)
	 * Time quanta segment 2 is 1 (value - 1)
	 * Baud is 100kbps
	 * */
	/*Reset the non-zero initial values*/
  CAN1->BTR &=~ (CAN_BTR_TS1_Msk|CAN_BTR_TS2_Msk|CAN_BTR_SJW_Msk);
  CAN1->BTR  =  (1<<CAN_BTR_TS1_Pos)|(0<<CAN_BTR_TS2_Pos)|(9U<<CAN_BTR_BRP_Pos);
}

void CANBus_L476_Filter_Configuration(void)
{
	/* Set the filter initialization mode*/
	CAN1->FMR |= CAN_FMR_FINIT;

	/* Deactivate filter bank 0 before config */
	CAN1->FA1R &=~ (CAN_FA1R_FACT0);

	CAN1->FS1R |= CAN_FS1R_FSC0;  // Set to 1 for 32-bit scale configuration

	CAN1->FM1R &= ~CAN_FM1R_FBM0; // Set to 0 for identifier mask mode

	/* Accept following IDs: 0x1A1, 0x7E1, 0x9A1 */
	CAN1->sFilterRegister[0].FR1 = (0x1A1 << 5); // Identifier

	CAN1->sFilterRegister[0].FR2 = (0x7E1 << 5); // Identifier mask 
	
	/*Assign filter 0 to FIFO0*/
	CAN1->FFA1R&=~CAN_FFA1R_FFA0;

	// Activate filter 0
	CAN1->FA1R |= CAN_FFA1R_FFA0;

	CAN1->FMR &= ~CAN_FMR_FINIT; // Clear the filter initialization mode
}

void CANBus_L476_Start(void)
{
	// Leave Initialization mode
  CAN1->MCR &= ~CAN_MCR_INRQ;
  while (CAN1->MSR & CAN_MSR_INAK);
}

void CANBus_L476_SendMessage(CANBusTxFrameDef *TXFrame)
{
	// Wait until the transmit mailbox is empty
  while ((CAN1->TSR & CAN_TSR_TME0) == 0){}
	
	// Set the standard identifier and data length
  CAN1->sTxMailBox[0].TIR &= ~CAN_TI0R_STID;
		
	// Configure the transmit mailbox identifier
  CAN1->sTxMailBox[0].TIR |= (TXFrame->identifier << 21);
		
  // Configure data length
  CAN1->sTxMailBox[0].TDTR |= (TXFrame->length << 0);
		
	CAN1->sTxMailBox[0].TDLR=
				((uint32_t)TXFrame->data[3] << CAN_TDL0R_DATA3_Pos) |
				((uint32_t)TXFrame->data[2] << CAN_TDL0R_DATA2_Pos) |
				((uint32_t)TXFrame->data[1] << CAN_TDL0R_DATA1_Pos) |
				((uint32_t)TXFrame->data[0] << CAN_TDL0R_DATA0_Pos);

	CAN1->sTxMailBox[0].TDHR=
				((uint32_t)TXFrame->data[7] << CAN_TDH0R_DATA7_Pos) |
				((uint32_t)TXFrame->data[6] << CAN_TDH0R_DATA6_Pos) |
				((uint32_t)TXFrame->data[5] << CAN_TDH0R_DATA5_Pos) |
				((uint32_t)TXFrame->data[4] << CAN_TDH0R_DATA4_Pos);
	
	// Set the TXRQ bit to request transmission
  CAN1->sTxMailBox[0].TIR |= CAN_TI0R_TXRQ;
}

void CANBus_L476_ReceiveMessage(CANBusRxFrameDef *RXFrame)
{
	if (CAN1->RF0R & CAN_RF0R_FMP0)
	{
		// Read the received identifier
    RXFrame->identifier = (CAN1->sFIFOMailBox[0].RIR >> 3) & 0x1FFFFFFF;
		
		// Read the data length
    RXFrame->length = CAN1->sFIFOMailBox[0].RDTR & 0x0F;
		
		/*Clear old data*/
    for (int i=0;i<8;i++)
    {
    	RXFrame->data[i]=0;
    }
		
		RXFrame->data[0]=CAN1->sFIFOMailBox[0].RDLR >>CAN_RDL0R_DATA0_Pos;
		RXFrame->data[1]=CAN1->sFIFOMailBox[0].RDLR >>CAN_RDL0R_DATA1_Pos;
		RXFrame->data[2]=CAN1->sFIFOMailBox[0].RDLR >>CAN_RDL0R_DATA2_Pos;
		RXFrame->data[3]=CAN1->sFIFOMailBox[0].RDLR >>CAN_RDL0R_DATA3_Pos;

		RXFrame->data[4]=CAN1->sFIFOMailBox[0].RDHR >>CAN_RDH0R_DATA4_Pos;
		RXFrame->data[5]=CAN1->sFIFOMailBox[0].RDHR >>CAN_RDH0R_DATA5_Pos;
		RXFrame->data[6]=CAN1->sFIFOMailBox[0].RDHR >>CAN_RDH0R_DATA6_Pos;
		RXFrame->data[7]=CAN1->sFIFOMailBox[0].RDHR >>CAN_RDH0R_DATA7_Pos;
		
		// Release the FIFO (not necessary for FIFO0)
    CAN1->RF0R |= CAN_RF0R_RFOM0;
	}
}
